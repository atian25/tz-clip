import Cocoa

enum InteractionState {
    case idle
    case creating
    case selected
    case moving
    case resizing(Handle)
}

enum Handle: CaseIterable {
    case topLeft, top, topRight
    case left, right
    case bottomLeft, bottom, bottomRight
}

class SelectionView: NSView, AnnotationToolbarDelegate, AnnotationPropertiesDelegate {
    private var startPoint: NSPoint?
    private var selectionRect: NSRect = .zero
    private var state: InteractionState = .idle
    private var lastMouseLocation: NSPoint?
    private var snappedEdges: Set<Int> = []
    private let snapThreshold: CGFloat = 10.0
    var windowProvider: WindowInfoProvider?
    private var highlightWindowRect: NSRect?
    private var pendingWindowRect: NSRect?
    private let highlightColor = NSColor.systemBlue.withAlphaComponent(0.2)
    private let highlightBorderColor = NSColor.systemBlue
    private var cursorLocation: NSPoint?
    var isInitialized: Bool = false
    private let handleSize: CGFloat = 8.0
    private let overlayColor = NSColor.black.withAlphaComponent(0.5)
    private let borderColor = NSColor.white
    private let borderWidth: CGFloat = 1.0
    private var toolbarView: AnnotationToolbar?
    private var propertiesView: AnnotationPropertiesView?
    private var annotationOverlay: AnnotationOverlayView?
    private var commandBus: CommandBus?
    private var selectionController: SelectionController?
    private var trackingArea: NSTrackingArea?
    override var acceptsFirstResponder: Bool { true }
    override func acceptsFirstMouse(for event: NSEvent?) -> Bool { true }
    override var isFlipped: Bool { false }
    override func updateTrackingAreas() { super.updateTrackingAreas(); if let trackingArea = trackingArea { removeTrackingArea(trackingArea) }; let options: NSTrackingArea.Options = [.mouseEnteredAndExited, .mouseMoved, .activeAlways]; trackingArea = NSTrackingArea(rect: bounds, options: options, owner: self, userInfo: nil); addTrackingArea(trackingArea!) }
    override func draw(_ dirtyRect: NSRect) { super.draw(dirtyRect); if case .idle = state, isInitialized { if let highlightRect = highlightWindowRect { highlightBorderColor.setStroke(); let path = NSBezierPath(rect: highlightRect); path.lineWidth = 2.0; path.stroke() } }; if case .idle = state, isInitialized, let p = cursorLocation { drawCrosshair(at: p) }; if !selectionRect.isEmpty { borderColor.setStroke(); let path = NSBezierPath(rect: selectionRect); path.lineWidth = borderWidth; path.stroke(); drawSnapGuides(); if case .creating = state { } else { drawHandles() }; drawSizeIndicator() } }
    private func drawCrosshair(at point: NSPoint) { let color = NSColor.white.withAlphaComponent(0.3); color.setStroke(); let path = NSBezierPath(); path.lineWidth = 1.0; path.move(to: NSPoint(x: bounds.minX, y: point.y)); path.line(to: NSPoint(x: bounds.maxX, y: point.y)); path.move(to: NSPoint(x: point.x, y: bounds.minY)); path.line(to: NSPoint(x: point.x, y: bounds.maxY)); path.stroke() }
    private func drawHandles() { NSColor.white.setFill(); for handle in Handle.allCases { let rect = rectForHandle(handle); let path = NSBezierPath(ovalIn: rect); path.fill() } }
    private func drawSnapGuides() { guard !snappedEdges.isEmpty else { return }; let guideColor = NSColor.systemYellow; guideColor.setStroke(); let path = NSBezierPath(); path.lineWidth = 1.0; path.setLineDash([4.0, 2.0], count: 2, phase: 0); if snappedEdges.contains(0) { path.move(to: NSPoint(x: selectionRect.minX, y: bounds.minY)); path.line(to: NSPoint(x: selectionRect.minX, y: bounds.maxY)) }; if snappedEdges.contains(1) { path.move(to: NSPoint(x: selectionRect.maxX, y: bounds.minY)); path.line(to: NSPoint(x: selectionRect.maxX, y: bounds.maxY)) }; if snappedEdges.contains(2) { path.move(to: NSPoint(x: bounds.minX, y: selectionRect.minY)); path.line(to: NSPoint(x: bounds.maxX, y: selectionRect.minY)) }; if snappedEdges.contains(3) { path.move(to: NSPoint(x: bounds.minX, y: selectionRect.maxY)); path.line(to: NSPoint(x: bounds.maxX, y: selectionRect.maxY)) }; path.stroke() }
    private func drawSizeIndicator() { let width = Int(round(selectionRect.width)); let height = Int(round(selectionRect.height)); let text = "\(width) Ã— \(height)"; let attrs: [NSAttributedString.Key: Any] = [.font: NSFont.systemFont(ofSize: 12, weight: .medium), .foregroundColor: NSColor.white]; let size = text.size(withAttributes: attrs); let padding: CGFloat = 4; let bgRectSize = NSSize(width: size.width + padding * 2, height: size.height + padding * 2); var origin = NSPoint(x: selectionRect.minX, y: selectionRect.maxY + 6); if origin.y + bgRectSize.height > bounds.maxY { origin.y = selectionRect.maxY - bgRectSize.height - 6 }; if origin.x < bounds.minX { origin.x = bounds.minX + 4 }; if origin.x + bgRectSize.width > bounds.maxX { origin.x = bounds.maxX - bgRectSize.width - 4 }; let bgRect = NSRect(origin: origin, size: bgRectSize); NSGraphicsContext.saveGraphicsState(); let path = NSBezierPath(roundedRect: bgRect, xRadius: 4, yRadius: 4); NSColor.black.withAlphaComponent(0.7).setFill(); path.fill(); NSGraphicsContext.restoreGraphicsState(); let textPoint = NSPoint(x: origin.x + padding, y: origin.y + padding); text.draw(at: textPoint, withAttributes: attrs) }
    private func rectForHandle(_ handle: Handle) -> NSRect { HandleGeometryService.rect(for: handle, in: selectionRect, handleSize: handleSize) }
    private func handle(at point: NSPoint) -> Handle? { HandleGeometryService.handle(at: point, selectionRect: selectionRect, handleSize: handleSize) }
    override func hitTest(_ point: NSPoint) -> NSView? { if let toolbar = toolbarView, NSPointInRect(point, toolbar.frame) { return super.hitTest(point) }; if let props = propertiesView, !props.isHidden, NSPointInRect(point, props.frame) { return super.hitTest(point) }; if let overlay = annotationOverlay, !overlay.isHidden { if overlay.currentTool != nil && NSPointInRect(point, overlay.frame) { return overlay } }; return self }
    override func mouseMoved(with event: NSEvent) { let p = convert(event.locationInWindow, from: nil); if selectionRect.isEmpty { if case .idle = state, isInitialized { cursorLocation = p; if !event.modifierFlags.contains(.command), let provider = windowProvider { let globalMouseLocation = NSEvent.mouseLocation; if let detected = provider.window(at: globalMouseLocation) { if let window = self.window { highlightWindowRect = window.convertFromScreen(detected.frame) } } else { highlightWindowRect = nil } } else { highlightWindowRect = nil }; needsDisplay = true; NSCursor.crosshair.set() }; return }; cursorLocation = nil; highlightWindowRect = nil; if let h = handle(at: p) { cursorForHandle(h).set() } else if selectionRect.contains(p) { NSCursor.openHand.set() } else { NSCursor.crosshair.set() } }
    override func mouseExited(with event: NSEvent) { cursorLocation = nil; needsDisplay = true; super.mouseExited(with: event) }
    private func cursorForHandle(_ handle: Handle) -> NSCursor { switch handle { case .top, .bottom: return .resizeUpDown; case .left, .right: return .resizeLeftRight; default: return .crosshair } }
    override func mouseDown(with event: NSEvent) { window?.makeFirstResponder(self); let p = convert(event.locationInWindow, from: nil); startPoint = p; lastMouseLocation = p; if !selectionRect.isEmpty { if let h = handle(at: p) { state = .resizing(h); propertiesView?.isHidden = true; return }; if selectionRect.contains(p) { state = .moving; NSCursor.closedHand.set(); propertiesView?.isHidden = true; return } } else { if let highlight = highlightWindowRect, !event.modifierFlags.contains(.command) { pendingWindowRect = highlight } }; if !selectionRect.isEmpty { startPoint = p; return }; state = .creating; selectionRect = .zero; cursorLocation = nil; highlightWindowRect = nil; propertiesView?.isHidden = true; needsDisplay = true }
    override func mouseDragged(with event: NSEvent) { let p = convert(event.locationInWindow, from: nil); let deltaX = p.x - (lastMouseLocation?.x ?? p.x); let deltaY = p.y - (lastMouseLocation?.y ?? p.y); lastMouseLocation = p; if pendingWindowRect != nil { if let start = startPoint { let dragDist = hypot(p.x - start.x, p.y - start.y); if dragDist > 3.0 { pendingWindowRect = nil } } }; if case .selected = state, let start = startPoint, !selectionRect.contains(start) { let dragDist = hypot(p.x - start.x, p.y - start.y); if dragDist > 3.0 { state = .creating; selectionRect = .zero; propertiesView?.isHidden = true } }; switch state { case .creating: guard let start = startPoint else { return }; selectionRect = NSRect(x: min(start.x, p.x), y: min(start.y, p.y), width: abs(p.x - start.x), height: abs(p.y - start.y)); case .moving: selectionRect.origin.x += deltaX; selectionRect.origin.y += deltaY; case .resizing(let handle): resizeSelection(handle: handle, deltaX: deltaX, deltaY: deltaY); default: break }; if !event.modifierFlags.contains(.command) { selectionRect = applySnapping(to: selectionRect) } else { snappedEdges.removeAll() }; needsDisplay = true; if let overlay = annotationOverlay { overlay.frame = selectionRect }; positionToolbar() }
    override func mouseUp(with event: NSEvent) { snappedEdges.removeAll(); if case .creating = state { if let windowRect = pendingWindowRect { selectionRect = windowRect; state = .selected; setupAnnotationOverlay(); positionToolbar(); pendingWindowRect = nil } else if selectionRect.width > 10 && selectionRect.height > 10 { state = .selected; setupAnnotationOverlay(); positionToolbar() } else { state = .idle; selectionRect = .zero } } else { state = .selected; NSCursor.openHand.set(); if let overlay = annotationOverlay { overlay.frame = selectionRect } else { setupAnnotationOverlay() }; positionToolbar() }; startPoint = nil; lastMouseLocation = nil; pendingWindowRect = nil; needsDisplay = true }
    private func setupAnnotationOverlay() { if annotationOverlay == nil { let overlay = AnnotationOverlayView(frame: selectionRect); addSubview(overlay); annotationOverlay = overlay } else { annotationOverlay?.frame = selectionRect; annotationOverlay?.isHidden = false }; if commandBus == nil { commandBus = CommandBus(getImage: { [weak self] in self?.generateFinalImage() }, onUndo: { [weak self] in self?.annotationOverlay?.undo() ?? () }, onRedo: { [weak self] in self?.annotationOverlay?.redo() ?? () }, onDeleteSelected: { [weak self] in self?.annotationOverlay?.deleteSelected() ?? () }, onClose: { [weak self] in self?.handleCancel() }, onSave: { [weak self] image in self?.saveImageToFile(image) }, onCopy: { [weak self] image in self?.copyImageToClipboard(image); NotificationCenter.default.post(name: .stopCapture, object: nil) }, onPin: { _ in }, onOCR: { _ in }, onScrollShot: { _ in }) }; if selectionController == nil, let props = propertiesView { selectionController = SelectionController(overlay: annotationOverlay, propertiesView: props, commandBus: commandBus) } else if let props = propertiesView, let overlay = annotationOverlay { selectionController?.attachOverlay(overlay); selectionController?.attachPropertiesView(props); if let bus = commandBus { selectionController?.attachCommandBus(bus) } }; annotationOverlay?.onSelectionChange = { [weak self] annotation in guard let self = self, let props = self.propertiesView else { return }; if let annot = annotation { if let counter = annot as? CounterAnnotation { let textColor = counter.label?.color ?? counter.color; props.selectedColor = textColor; self.selectionController?.didChangeColor(textColor) } else { props.selectedColor = annot.color; self.selectionController?.didChangeColor(annot.color) }; props.selectedWidth = annot.lineWidth; if let textAnnot = annot as? TextAnnotation { props.isBold = textAnnot.isBold; props.outlineStyle = textAnnot.outlineStyle; props.outlineColor = textAnnot.outlineColor; props.fontName = textAnnot.fontName; props.textBackgroundColor = textAnnot.backgroundColor; self.selectionController?.didChangeTextBackgroundColor(textAnnot.backgroundColor) }; if let rectAnnot = annot as? RectangleAnnotation { props.isFilled = rectAnnot.isFilled; props.isRounded = rectAnnot.isRounded }; if let ellAnnot = annot as? EllipseAnnotation { props.isFilled = ellAnnot.isFilled }; if let counterAnnot = annot as? CounterAnnotation { props.isBold = counterAnnot.label?.isBold ?? counterAnnot.isBold; props.fontName = counterAnnot.label?.fontName ?? counterAnnot.fontName; let bg = counterAnnot.label?.backgroundColor ?? counterAnnot.backgroundColor; props.textBackgroundColor = bg; self.selectionController?.didChangeTextBackgroundColor(bg) }; props.configure(for: annot.type); props.isHidden = false; self.updatePropertiesLayout() } else { if let tool = self.annotationOverlay?.currentTool, (tool == .text || tool == .counter) { props.isHidden = false; self.updatePropertiesLayout() } else { props.isHidden = true } } }
        annotationOverlay?.onToolChange = { [weak self] tool in guard let self = self, let toolbar = self.toolbarView else { return }; toolbar.selectTool(tool); self.didSelectTool(tool) }
    }
    private func applySnapping(to rect: NSRect) -> NSRect { let result = SnapService.apply(rect: rect, in: bounds, threshold: snapThreshold); snappedEdges = result.1; return result.0 }
    private func resizeSelection(handle: Handle, deltaX: CGFloat, deltaY: CGFloat) { let old = selectionRect; var r = selectionRect; let minSize: CGFloat = 10.0; switch handle { case .left: let newWidth = r.size.width - deltaX; if newWidth >= minSize { r.origin.x += deltaX; r.size.width = newWidth } case .right: let newWidth = r.size.width + deltaX; if newWidth >= minSize { r.size.width = newWidth } case .bottom: let newHeight = r.size.height - deltaY; if newHeight >= minSize { r.origin.y += deltaY; r.size.height = newHeight } case .top: let newHeight = r.size.height + deltaY; if newHeight >= minSize { r.size.height = newHeight } case .topLeft: let newWidth = r.size.width - deltaX; let newHeight = r.size.height + deltaY; if newWidth >= minSize { r.origin.x += deltaX; r.size.width = newWidth }; if newHeight >= minSize { r.size.height = newHeight } case .topRight: let newWidth = r.size.width + deltaX; let newHeight = r.size.height + deltaY; if newWidth >= minSize { r.size.width = newWidth }; if newHeight >= minSize { r.size.height = newHeight } case .bottomLeft: let newWidth = r.size.width - deltaX; let newHeight = r.size.height - deltaY; if newWidth >= minSize { r.origin.x += deltaX; r.size.width = newWidth }; if newHeight >= minSize { r.origin.y += deltaY; r.size.height = newHeight } case .bottomRight: let newWidth = r.size.width + deltaX; let newHeight = r.size.height - deltaY; if newWidth >= minSize { r.size.width = newWidth }; if newHeight >= minSize { r.origin.y += deltaY; r.size.height = newHeight } }; selectionRect = r; let dx = selectionRect.origin.x - old.origin.x; let dy = selectionRect.origin.y - old.origin.y; if let overlay = annotationOverlay, (dx != 0 || dy != 0) { overlay.translateAnnotations(by: NSPoint(x: dx, y: dy)) } }
    override func keyDown(with event: NSEvent) { if event.modifierFlags.contains(.command) && event.charactersIgnoringModifiers == "a" { if let overlay = annotationOverlay, overlay.performKeyEquivalent(with: event) { return } }; if event.keyCode == 53 { handleCancel(); return }; if event.modifierFlags.contains(.command) && event.charactersIgnoringModifiers == "q" { NSApp.terminate(nil); return }; if event.modifierFlags.contains([.command, .shift]) && event.charactersIgnoringModifiers == "Z" { annotationOverlay?.redo(); return } ; if event.modifierFlags.contains(.command) && event.charactersIgnoringModifiers == "z" { annotationOverlay?.undo(); return }; if (event.keyCode == 51 || event.keyCode == 117) { annotationOverlay?.deleteSelected(); return }; if !selectionRect.isEmpty { let shift = event.modifierFlags.contains(.shift); let option = event.modifierFlags.contains(.option); let step: CGFloat = shift ? 10.0 : 1.0; var dx: CGFloat = 0; var dy: CGFloat = 0; var dWidth: CGFloat = 0; var dHeight: CGFloat = 0; var handled = false; if let specialKey = event.specialKey { switch specialKey { case .leftArrow: if option { dWidth = -step } else { dx = -step }; handled = true; case .rightArrow: if option { dWidth = step } else { dx = step }; handled = true; case .upArrow: if option { dHeight = step } else { dy = step }; handled = true; case .downArrow: if option { dHeight = -step } else { dy = -step }; handled = true; default: break } }; if handled { if option { var newRect = selectionRect; newRect.size.width = max(10, newRect.width + dWidth); newRect.size.height = max(10, newRect.height + dHeight); selectionRect = newRect } else { selectionRect.origin.x += dx; selectionRect.origin.y += dy }; needsDisplay = true; if let controller = selectionController { controller.updateSelectionRect(selectionRect) }; positionToolbar(); return } }; super.keyDown(with: event) }
    private func showToolbar() { hideToolbar(); let toolbar = AnnotationToolbar(frame: .zero); toolbar.delegate = self; addSubview(toolbar); toolbarView = toolbar; let props = AnnotationPropertiesView(frame: .zero); props.delegate = self; addSubview(props); propertiesView = props; props.isHidden = true; if let controller = selectionController { controller.positionUI(selectionRect: selectionRect, bounds: bounds, toolbar: toolbar, props: props) } }
    private func hideToolbar() { toolbarView?.removeFromSuperview(); toolbarView = nil; propertiesView?.removeFromSuperview(); propertiesView = nil }
    private func positionToolbar() { if toolbarView == nil || propertiesView == nil { showToolbar() }; guard let toolbar = toolbarView, let props = propertiesView else { return }; if let controller = selectionController { controller.positionUI(selectionRect: selectionRect, bounds: bounds, toolbar: toolbar, props: props) } }
    private func handleCancel() { if let overlay = annotationOverlay, !overlay.isHidden { }; if !selectionRect.isEmpty { selectionRect = .zero; state = .idle; hideToolbar(); annotationOverlay?.isHidden = true; annotationOverlay?.clear(); needsDisplay = true } else { NotificationCenter.default.post(name: .stopCapture, object: nil) } }
    func didSelectTool(_ tool: AnnotationType) { annotationOverlay?.currentTool = tool; propertiesView?.configure(for: tool); if let overlay = annotationOverlay { propertiesView?.selectedColor = overlay.currentColor; propertiesView?.selectedWidth = overlay.currentLineWidth; if tool == .text || tool == .counter { propertiesView?.isBold = overlay.currentIsBold; propertiesView?.outlineStyle = overlay.currentOutlineStyle; propertiesView?.outlineColor = overlay.currentOutlineColor; propertiesView?.fontName = overlay.currentFontName; propertiesView?.textBackgroundColor = overlay.currentTextBackgroundColor }; if tool == .rectangle { propertiesView?.isRounded = overlay.currentIsRounded }; propertiesView?.isFilled = overlay.currentIsFilled }; if tool == .select { propertiesView?.isHidden = !(annotationOverlay?.hasSelection ?? false) } else { propertiesView?.isHidden = false }; updatePropertiesLayout(); selectionController?.didSelectTool(tool) }
    func didSelectAction(_ action: ToolbarAction) { if selectionController == nil { if commandBus == nil { commandBus = CommandBus(getImage: { [weak self] in self?.generateFinalImage() }, onUndo: { [weak self] in self?.annotationOverlay?.undo() ?? () }, onClose: { [weak self] in self?.handleCancel() }, onSave: { [weak self] image in self?.saveImageToFile(image) }, onCopy: { [weak self] image in self?.copyImageToClipboard(image); NotificationCenter.default.post(name: .stopCapture, object: nil) }) }; selectionController = SelectionController(overlay: annotationOverlay, propertiesView: propertiesView, commandBus: commandBus) }; selectionController?.didSelectAction(action) }
    func generateFinalImage() -> NSImage? { guard !selectionRect.isEmpty, let window = self.window else { return nil }; let screenRect = window.convertToScreen(selectionRect); guard let primaryScreen = NSScreen.screens.first else { return nil }; let primaryHeight = primaryScreen.frame.height; let quartzY = primaryHeight - (screenRect.origin.y + screenRect.height); let captureRect = CGRect(x: screenRect.origin.x, y: quartzY, width: screenRect.width, height: screenRect.height); guard let cgImage = CGWindowListCreateImage(captureRect, .optionOnScreenBelowWindow, CGWindowID(window.windowNumber), .bestResolution) else { print("Failed to capture screen image"); return nil }; let finalImage = NSImage(size: selectionRect.size); finalImage.lockFocus(); let baseNSImage = NSImage(cgImage: cgImage, size: selectionRect.size); baseNSImage.draw(in: NSRect(origin: .zero, size: selectionRect.size), from: NSRect(origin: .zero, size: selectionRect.size), operation: .copy, fraction: 1.0); if let ctx = NSGraphicsContext.current?.cgContext { annotationOverlay?.renderAnnotations(in: ctx) }; finalImage.unlockFocus(); return finalImage }
    func copyImageToClipboard(_ image: NSImage) { let pasteboard = NSPasteboard.general; pasteboard.clearContents(); pasteboard.writeObjects([image]) }
    func saveImageToFile(_ image: NSImage) { let savePanel = NSSavePanel(); savePanel.allowedContentTypes = [.png, .jpeg]; savePanel.canCreateDirectories = true; savePanel.nameFieldStringValue = "Screenshot \(Date().formatted(date: .numeric, time: .standard)).png".replacingOccurrences(of: "/", with: "-").replacingOccurrences(of: ":", with: "."); savePanel.level = NSWindow.Level(rawValue: Int(CGWindowLevelForKey(.screenSaverWindow)) + 1); savePanel.begin { response in if response == .OK, let url = savePanel.url { if let tiffData = image.tiffRepresentation, let bitmapRep = NSBitmapImageRep(data: tiffData) { let props: [NSBitmapImageRep.PropertyKey: Any] = [:]; let fileType: NSBitmapImageRep.FileType = url.pathExtension.lowercased() == "jpg" ? .jpeg : .png; if let data = bitmapRep.representation(using: fileType, properties: props) { try? data.write(to: url) } }; NotificationCenter.default.post(name: .stopCapture, object: nil) } }
    }
    func didChangeColor(_ color: NSColor) { selectionController?.didChangeColor(color) }
    func didChangeLineWidth(_ width: CGFloat) { selectionController?.didChangeLineWidth(width) }
    func didChangeIsBold(_ isBold: Bool) { selectionController?.didChangeIsBold(isBold) }
    func didChangeIsFilled(_ isFilled: Bool) { selectionController?.didChangeIsFilled(isFilled) }
    func didChangeIsRounded(_ isRounded: Bool) { selectionController?.didChangeIsRounded(isRounded) }
    func didChangeOutlineStyle(_ style: Int) { selectionController?.didChangeOutlineStyle(style) }
    func didChangeOutlineColor(_ color: NSColor) { selectionController?.didChangeOutlineColor(color) }
    func didChangeFontName(_ name: String) { selectionController?.didChangeFontName(name) }
    func didChangeTextBackgroundColor(_ color: NSColor?) { selectionController?.didChangeTextBackgroundColor(color) }
    func updatePropertiesLayout() { guard let toolbar = toolbarView, let props = propertiesView else { return }; let hasSelection = annotationOverlay?.hasSelection ?? false; if !hasSelection, let tool = annotationOverlay?.currentTool { props.configure(for: tool) }; let propsSize = props.fittingSize == .zero ? props.frame.size : props.fittingSize; let padding: CGFloat = 8; let toolbarY = toolbar.frame.minY; var propsY: CGFloat; if toolbarY < (propsSize.height + padding) { propsY = toolbar.frame.maxY + padding } else { propsY = toolbarY - padding - propsSize.height }; if propsY < 0 { propsY = toolbar.frame.maxY + padding }; var finalX = toolbar.frame.minX; finalX = min(bounds.width - propsSize.width - padding, max(padding, finalX)); props.setFrameSize(propsSize); props.frame.origin = NSPoint(x: finalX, y: propsY) }
}
